### <center>화이트데이<center>

|    Constraints    | Time Complexity |
| :---------------: | :-------------: |
| $1\le N \le 5000$ |   $O(N^{2})$    |

#### 풀이

---

아기 호랑이가 태어났는지를 기록하는 배열을 $check[i]$라고 하면,

첫번째 반복문을 $i=n$부터 $i = 1$까지 돌리면서,  $check[i] $를 구해주면 됩니다.
$$
check[i]=a[i] - \sum_{j=i의 배수 \&\& j\not=i}^{}{check[j]}
$$
$\sum$연산 역시 반복문으로 구현해주어야 하는데요

$j$를 $1$씩 증가시키면서, $j\% i == 0$인 경우를 계산해주면, 첫 번째 반복문을 도는데 $O(N)$, 두 번째 반복문을 도는데 $O(N)$이 걸려서 총 시간복잡도는$O(N^{2})$가 됩니다.



혹은 $j$를 $i$씩 증가시키는 방법으로 구현해도 되는데, 총 계산량이  $\sum_{i=1}^{i=N}{{N} \over {i}}$ 이어서, 약 $O(NlnN)$에 빠르게 계산됩니다. 



이 문제는 제한을 작게 두어서 어떤 방식으로 풀어도 상관은 없지만, 흥미로운 방법이니 알아두는 것도 좋을 것 같습니다 :-)

#### 기타

------

예상대로 많은 분들이 문제를 풀어주셨고, 사람마다 구현방법이 조금씩 달라서 제출을 보면서 즐거웠습니다 :) 의외로 오답이 살짝 많은 문제였는데 제가 본 코드 중에서는 다음과 같은 오답의 원인이 있었습니다. 

1. 첫 번째 반복문을 $i=n$부터 $i>=2$까지만 돌리는 경우
2. $a[i]>=2$인 경우에만 두 번째 반복문을 실행시키는 경우 
3. 두 번째 반복문의 종료 조건을 $j*j \le n$으로 두는 경우

물론 다른 원인이 있을 수도 있습니다. 세 경우를 포함하여 대부분의 오답이 사소한 실수로 인한 것이므로, 꼼꼼히 구현하다면 쉽게 맞을 수 있습니다. 어서 페레로 로쉐를 받아가주세요 ~ !
